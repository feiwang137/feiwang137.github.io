# linux软中断

理论知识很多，不抄了，具体看这里吧！https://time.geekbang.org/column/article/71868 

这里摘抄部分！


## 软中断

进程的不可中断状态是系统的一种保护机制，可以保证硬件的交互过程不被意外打断。它会打断进程的正常调度和执行，然后调用内核中的中断处理程序来响应设备的请求。


### 为什么要有中断？

取外卖的例子：
订了一份外卖，但是不知道外卖员什么时候到，于是就一直在等着，做不了其他的事情。但现在和外卖员默认沟通好，等他到了就给我打电话。收到他的电话（中断）才去取外卖。中断其实是一种异步的事件处理机制，可以提高系统的并发处理能力。

由于中断处理程序会打断其他进程的运行，所以，为了减少对正常进程运行调度的影响，中断处理程序就需要尽可能快地运行。

但是当定了多份外卖时，你接听第一个外卖员的电话，第二个外卖员也到了给你电话就打不通了，于是就存在中断丢失的情况。


为了解决中断处理程序执行过长和中断丢失的问题，Linux 将中断处理过程分成了两个阶段，也就是上半部和下半部：
- 上半部用来快速处理中断，它在中断禁止模式下运行，主要处理跟硬件紧密相关的或时间敏感的工作。 硬中断 特点是快速执行；
- 下半部用来延迟处理上半部未完成的工作，通常以内核线程的方式运行。 软中断 特点是延迟执行。

上半部会打断 CPU 正在执行的任务，然后立即执行中断处理程序。而下半部以内核线程的方式执行，并且每个 CPU 都对应一个软中断内核线程，名字为 “ksoftirqd/CPU 编号”，比如说， 0 号 CPU 对应的软中断内核线程的名字就是 ksoftirqd/0。


不过要注意的是，软中断不只包括了刚刚所讲的硬件设备中断处理程序的下半部，一些内核自定义的事件也属于软中断，比如内核调度和 RCU 锁（Read-Copy Update 的缩写，RCU 是 Linux 内核中最常用的锁之一）等。

### 如何查看软中断和内核线程

proc 文件系统，它是一种内核空间和用户空间进行通信的机制，可以用来查看内核的数据结构，或者用来动态修改内核的配置。

/proc/softirqs 提供了软中断的运行情况；
/proc/interrupts 提供了硬中断的运行情况。

```
$ cat /proc/softirqs
                    CPU0       CPU1
          HI:          0          0
       TIMER:     811613    1972736
      NET_TX:         49          7
      NET_RX:    1136736    1506885
       BLOCK:          0          0
    IRQ_POLL:          0          0
     TASKLET:     304787       3691 <----------
       SCHED:     689718    1897539
     HRTIMER:          0          0
         RCU:    1330771    1354737

```

在查看 /proc/softirqs 文件内容时，你要特别注意以下这两点:

第一，要注意软中断的类型，也就是这个界面中第一列的内容。从第一列你可以看到，软中断包括了 10 个类别，分别对应不同的工作类型。比如 NET_RX 表示网络接收中断，而 NET_TX 表示网络发送中断。

第二，要注意同一种软中断在不同 CPU 上的分布情况，也就是同一行的内容。正常情况下，同一种中断在不同 CPU 上的累积次数应该差不多。比如这个界面中，NET_RX 在 CPU0 和 CPU1 上的中断次数基本是同一个数量级，相差不大。

TASKLET 在不同 CPU 上的分布并不均匀。TASKLET 是最常用的软中断实现机制，每个 TASKLET 只运行一次就会结束 ，并且只在调用它的函数所在的 CPU 上运行。使用 TASKLET 特别简便，当然也会存在一些问题，比如说由于只在一个 CPU 上运行导致的调度不均衡，再比如因为不能在多个 CPU 上并行运行带来了性能限制。


